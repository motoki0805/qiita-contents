---
title: LaravelのN+1問題、やりがちなミス7選と対策
tags:
  - Laravel
  - PHP
  - Eloquent
  - パフォーマンス
private: false
updated_at: ""
id: null
organization_url_name: null
slide: false
ignorePublish: false
---

## はじめに

実務でパフォーマンスチューニングの課題に取り組んでいた際、N+1 問題に遭遇しました。

最初は「なぜこんなに遅いのか」と原因の特定に時間がかかっていましたが、
実務を通じて、よくあるアンチパターンや特定方法が徐々に見えてきたので、共有していきたいと思います。

### N+1 問題とは

N+1 問題とは、データベースから取得した N 件のレコードに対して、関連データを取得するために追加で N 回のクエリが実行されてしまう問題です。

本来なら数回のクエリで済むところが、データ件数に比例してクエリが増加し、アプリケーションの応答速度が大幅に悪化します。

#### N+1 の由来

この名前は、実行されるクエリの回数から来ています。

- **最初の 1 回** - 親データを取得するクエリ
- **N 回** - 取得した N 件それぞれに対する関連データ取得クエリ

合計で **N + 1 回** のクエリが実行されるため、この名前が付きました。

**具体例:**

```php
// 100件のブログ記事を取得（1回目）
$posts = Post::all();  // ← これが「1」

// 各記事の著者情報を取得（100回）
foreach ($posts as $post) {
    echo $post->user->name;  // ← これが「N」（100回）
}
// 合計101回 = N(100) + 1
```

### なぜ N+1 問題が起きるのか

### パフォーマンスへの影響

## アンチパターン集

### パターン 1: ループ内での関連データ取得

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

### パターン 2: Eager Loading の未使用

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

### パターン 3: アクセサ内でのクエリ実行

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

### パターン 4: ビューでの遅延ロード

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

### パターン 5: ネストしたリレーションの見落とし

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

### パターン 6: コレクション操作時の問題

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

### パターン 7: 条件付きリレーションでのミス

#### 悪い例

#### 良い例

#### 実行されるクエリの比較

## N+1 問題の検出方法

### Laravel Debugbar を使う

### Telescope で確認する

### クエリログで確認する

## まとめ

### チェックリスト

### ベストプラクティス

### 参考にさせていただいた記事

https://zenn.dev/goldsaya/articles/3af48dadc6cc0f
